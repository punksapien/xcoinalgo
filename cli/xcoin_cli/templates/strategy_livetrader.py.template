"""
{{strategy_name}} - LiveTrader Strategy
Generated by xcoin CLI v{{xcoin_version}}
Created: {{creation_date}}
Author: {{author_name}}

This strategy uses the LiveTrader class structure for:
- Local testing with your own API keys
- Platform deployment with multi-tenant support
- Full control over CoinDCX API interactions
"""

import os
import sys
import requests
import hmac
import hashlib
import json
import csv
import logging
import time
import warnings
import pandas as pd
import pandas_ta as ta
import numpy as np
from decimal import Decimal, ROUND_DOWN
from typing import List, Dict, Any, Optional
from datetime import datetime, timezone

warnings.filterwarnings("ignore")


# ==============================================================================
# SECTION 1: CoinDCX API CLIENT
# ==============================================================================

class CoinDCXClient:
    """
    CoinDCX API Client for futures trading.
    Handles authentication, signing, and all API interactions.
    """

    def __init__(self, key: str, secret: str):
        self.api_key = key
        self.api_secret = secret.encode('utf-8')
        self.base_url = "https://api.coindcx.com"
        self.public_base_url = "https://public.coindcx.com"

    def _sign(self, data: str) -> str:
        """Generate HMAC-SHA256 signature for authenticated requests"""
        return hmac.new(self.api_secret, data.encode(), hashlib.sha256).hexdigest()

    def _make_public_request(self, method: str, endpoint: str, params: Optional[Dict[str, Any]] = None) -> Any:
        """Make request to public API (no authentication required)"""
        url = self.public_base_url + endpoint
        try:
            response = requests.request(method.upper(), url, params=params)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as err:
            logging.error(f"HTTP Error: {err.response.status_code} - {err.response.text}")
            raise
        except requests.exceptions.RequestException as e:
            logging.error(f"Request Exception: {e}")
            raise

    def _make_request(self, method: str, endpoint: str, payload: Optional[Dict[str, Any]] = None) -> Any:
        """Make authenticated request to private API"""
        url = self.base_url + endpoint

        if payload is None:
            payload = {}

        payload['timestamp'] = int(time.time() * 1000)
        json_body = json.dumps(payload, separators=(',', ':'))
        signature = self._sign(json_body)

        headers = {
            'Content-Type': 'application/json',
            'X-AUTH-APIKEY': self.api_key,
            'X-AUTH-SIGNATURE': signature
        }

        try:
            response = requests.request(method.upper(), url, data=json_body, headers=headers)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as err:
            logging.error(f"HTTP Error for {method} {url}: {err.response.status_code} - {err.response.text}")
            raise
        except requests.exceptions.RequestException as e:
            logging.error(f"Request Exception: {e}")
            raise

    def get_instrument_details(self, pair: str, margin_currency_short_name: str = "USDT") -> Dict[str, Any]:
        """Fetch instrument details (precision, increments, etc.)"""
        endpoint = "/exchange/v1/derivatives/futures/data/instrument"
        params = {"pair": pair, "margin_currency_short_name": margin_currency_short_name}
        return self._make_request('GET', endpoint, params)

    def get_instrument_candlesticks(self, pair: str, from_ts: int, to_ts: int, resolution: str) -> Dict[str, Any]:
        """Fetch historical candlestick data"""
        valid_resolutions = ["1", "5", "15", "30", "60", "1D", "1W", "1M"]
        if resolution not in valid_resolutions:
            raise ValueError(f"Resolution must be one of {valid_resolutions}")

        endpoint = "/market_data/candlesticks"
        params = {
            "pair": pair,
            "from": from_ts,
            "to": to_ts,
            "resolution": resolution,
            "pcode": "f"  # futures
        }
        return self._make_public_request('GET', endpoint, params=params)

    def get_wallet_details(self) -> List[Dict[str, Any]]:
        """Fetch futures wallet balances"""
        return self._make_request('GET', '/exchange/v1/derivatives/futures/wallets')

    def create_order(
        self,
        pair: str,
        side: str,
        order_type: str,
        total_quantity: float,
        leverage: int,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Create futures order.

        Args:
            pair: Trading pair (e.g., 'B-BTC_USDT')
            side: 'buy' or 'sell'
            order_type: 'market_order' or 'limit_order'
            total_quantity: Position size
            leverage: Leverage multiplier
            **kwargs: Additional params (price, stop_loss_price, take_profit_price, etc.)
        """
        order_details = {
            "side": side,
            "pair": pair,
            "order_type": order_type,
            "total_quantity": total_quantity,
            "leverage": leverage
        }

        # Optional parameters
        allowed_keys = [
            "price", "stop_price", "notification", "time_in_force", "hidden",
            "post_only", "margin_currency_short_name", "position_margin_type",
            "take_profit_price", "stop_loss_price", "client_order_id", "group_id"
        ]
        order_details.update({k: v for k, v in kwargs.items() if k in allowed_keys})

        if order_type == "market_order":
            order_details.pop("price", None)
            order_details.pop("time_in_force", None)

        payload = {"order": order_details}
        return self._make_request('POST', '/exchange/v1/derivatives/futures/orders/create', payload)

    def list_positions(
        self,
        page: int = 1,
        size: int = 10,
        margin_currency_short_name: List[str] = ["USDT"]
    ) -> List[Dict[str, Any]]:
        """List open positions"""
        payload = {
            "page": page,
            "size": size,
            "margin_currency_short_name": margin_currency_short_name
        }
        return self._make_request('POST', '/exchange/v1/derivatives/futures/positions', payload)

    def exit_position(self, position_id: str) -> Dict[str, Any]:
        """Close position by ID"""
        return self._make_request('POST', '/exchange/v1/derivatives/futures/positions/exit', {"id": position_id})


# ==============================================================================
# SECTION 2: LOGGING SETUP
# ==============================================================================

class CsvHandler(logging.FileHandler):
    """Custom log handler that writes errors to CSV for easy analysis"""

    def __init__(self, filename, mode='a', encoding=None, delay=False):
        super().__init__(filename, mode, encoding, delay)
        if os.path.getsize(filename) == 0:
            self._write_header()

    def _write_header(self):
        if self.stream is None:
            self.stream = self._open()
        csv_writer = csv.writer(self.stream)
        csv_writer.writerow(['timestamp', 'level', 'message', 'function', 'line'])
        self.flush()

    def emit(self, record):
        try:
            if self.stream is None:
                self.stream = self._open()
            csv_writer = csv.writer(self.stream)
            log_entry = [
                datetime.fromtimestamp(record.created).strftime('%Y-%m-%d %H:%M:%S'),
                record.levelname,
                record.getMessage(),
                record.funcName,
                record.lineno
            ]
            csv_writer.writerow(log_entry)
            self.flush()
        except Exception:
            self.handleError(record)


def setup_logging(log_file='trading_bot.log', csv_error_file='error_log.csv'):
    """
    Setup comprehensive logging:
    - Console output (INFO level)
    - File logging (all messages)
    - CSV error log (ERROR level only)
    """
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    if logger.hasHandlers():
        logger.handlers.clear()

    # Console handler
    log_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(log_formatter)
    logger.addHandler(console_handler)

    # File handler
    file_handler = logging.FileHandler(log_file, mode='a')
    file_handler.setFormatter(log_formatter)
    logger.addHandler(file_handler)

    # CSV error handler
    csv_error_handler = CsvHandler(csv_error_file)
    csv_error_handler.setLevel(logging.ERROR)
    logger.addHandler(csv_error_handler)


# ==============================================================================
# SECTION 3: LIVE TRADER CLASS
# ==============================================================================

class LiveTrader:
    """
    Main strategy executor.

    Modes:
    - Standalone: Run locally with single user's API keys
    - Platform: Run on platform with multiple subscribers
    """

    def __init__(self, settings: Dict[str, Any], subscribers: Optional[List[Dict[str, Any]]] = None):
        """
        Initialize LiveTrader.

        Args:
            settings: Strategy settings (pair, resolution, indicators, etc.)
            subscribers: List of subscribers (platform mode) or None (standalone mode)
                Each subscriber dict contains: {user_id, api_key, api_secret, capital, risk_per_trade, leverage}
        """
        self.settings = settings
        self.platform_mode = subscribers is not None

        # Setup subscribers
        if self.platform_mode:
            self.subscribers = subscribers
            logging.info(f"Platform mode: {len(subscribers)} subscribers")
        else:
            # Standalone mode: single subscriber (yourself)
            self.subscribers = [{
                'user_id': 'standalone',
                'api_key': settings['api_key'],
                'api_secret': settings['api_secret'],
                'capital': settings.get('capital', 100000),
                'risk_per_trade': settings['risk_per_trade'],
                'leverage': settings['leverage']
            }]
            logging.info("Standalone mode: single user")

        # Create CoinDCX clients for each subscriber
        self.clients = {}
        for sub in self.subscribers:
            self.clients[sub['user_id']] = CoinDCXClient(
                key=sub['api_key'],
                secret=sub['api_secret']
            )

        # Fetch instrument details (using first client, data is same for everyone)
        first_client = list(self.clients.values())[0]
        try:
            logging.info(f"Fetching instrument details for {self.settings['pair']}...")
            self.instrument_details = first_client.get_instrument_details(
                pair=self.settings['pair'],
                margin_currency_short_name=self.settings.get('margin_currency', 'USDT')
            )['instrument']
            self.qty_increment = Decimal(self.instrument_details['quantity_increment'])
            logging.info(f"Quantity precision: {self.qty_increment}")
        except Exception as e:
            logging.critical(f"FATAL: Could not fetch instrument details. Error: {e}", exc_info=True)
            sys.exit(1)

        # State tracking (for standalone mode)
        self.in_position = False
        self.current_position = None

    def get_latest_data(self) -> pd.DataFrame:
        """
        Fetch latest candlestick data.
        Uses any subscriber's client (data is same for everyone).
        """
        resolution_map = {"1": 60, "5": 300, "15": 900, "30": 1800, "60": 3600}
        resolution_seconds = resolution_map.get(self.settings['resolution'], 900)

        to_ts = int(datetime.now(timezone.utc).timestamp()) - resolution_seconds
        from_ts = to_ts - (200 * resolution_seconds)  # 200 candles lookback

        try:
            first_client = list(self.clients.values())[0]
            data = first_client.get_instrument_candlesticks(
                pair=self.settings['pair'],
                from_ts=from_ts,
                to_ts=to_ts,
                resolution=self.settings['resolution']
            )

            df = pd.DataFrame(data['data'])
            df['timestamp'] = pd.to_datetime(df['time'], unit='ms', utc=True)
            df.drop(columns=['time'], inplace=True)
            df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']]

            for col in ['open', 'high', 'low', 'close', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')

            df.sort_values('timestamp', inplace=True)
            df.reset_index(drop=True, inplace=True)

            logging.info(f"Fetched {len(df)} candles")
            return df
        except Exception as e:
            logging.error(f"Error fetching candlestick data: {e}", exc_info=True)
            return pd.DataFrame()

    def generate_signals(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        YOUR STRATEGY LOGIC GOES HERE.

        Calculate indicators and generate buy/sell signals.

        Returns:
            DataFrame with added columns: long_signal, short_signal, etc.
        """
        # TODO: Replace this with your strategy logic

        # Example: Simple EMA crossover strategy
        df['ema_fast'] = ta.ema(df['close'], length={{sma_fast_period}})
        df['ema_slow'] = ta.ema(df['close'], length={{sma_slow_period}})
        df['rsi'] = ta.rsi(df['close'], length=14)

        # Generate signals
        df['long_signal'] = (
            (df['ema_fast'] > df['ema_slow']) &
            (df['rsi'] < 70) &
            (df['ema_fast'].shift(1) <= df['ema_slow'].shift(1))
        )

        df['short_signal'] = (
            (df['ema_fast'] < df['ema_slow']) &
            (df['rsi'] > 30) &
            (df['ema_fast'].shift(1) >= df['ema_slow'].shift(1))
        )

        df.dropna(inplace=True)
        return df

    def calculate_position_size(
        self,
        capital: float,
        risk_per_trade: float,
        entry_price: float,
        stop_loss: float,
        leverage: int
    ) -> float:
        """
        Calculate position size based on risk parameters.

        Args:
            capital: Available capital
            risk_per_trade: Risk percentage (e.g., 0.05 for 5%)
            entry_price: Entry price
            stop_loss: Stop loss price
            leverage: Leverage multiplier

        Returns:
            Position size (quantity)
        """
        risk_amount = capital * risk_per_trade
        distance = abs(entry_price - stop_loss) / entry_price
        notional = risk_amount * leverage
        quantity = notional / entry_price

        # Round to instrument precision
        adjusted_quantity = (Decimal(str(quantity)) // self.qty_increment) * self.qty_increment
        return float(adjusted_quantity)

    def place_order_for_subscriber(
        self,
        subscriber: Dict[str, Any],
        signal: str,
        entry_price: float,
        stop_loss: float,
        take_profit: float
    ):
        """
        Place order for a single subscriber.

        Args:
            subscriber: Subscriber dict with user_id, capital, risk_per_trade, etc.
            signal: 'LONG' or 'SHORT'
            entry_price: Entry price
            stop_loss: Stop loss price
            take_profit: Take profit price
        """
        user_id = subscriber['user_id']
        client = self.clients[user_id]

        # Calculate position size for THIS subscriber
        quantity = self.calculate_position_size(
            capital=subscriber['capital'],
            risk_per_trade=subscriber['risk_per_trade'],
            entry_price=entry_price,
            stop_loss=stop_loss,
            leverage=subscriber['leverage']
        )

        if quantity <= 0:
            logging.warning(f"User {user_id}: Calculated quantity is zero, skipping")
            return

        try:
            logging.info(f"User {user_id}: Placing {signal} order for {quantity} @ {entry_price:.2f}")

            order_response = client.create_order(
                pair=self.settings['pair'],
                side='buy' if signal == 'LONG' else 'sell',
                order_type='market_order',
                total_quantity=quantity,
                leverage=subscriber['leverage'],
                stop_loss_price=stop_loss,
                take_profit_price=take_profit,
                client_order_id=f"{user_id}_{int(time.time())}",
                margin_currency_short_name=self.settings.get('margin_currency', 'USDT'),
                notification="email_notification"
            )

            logging.info(f"User {user_id}: Order placed successfully: {order_response}")
        except Exception as e:
            logging.error(f"User {user_id}: Failed to place order. Error: {e}", exc_info=True)

    def check_for_new_signal(self, df: pd.DataFrame):
        """
        Check for entry signals and place orders for ALL subscribers.
        """
        if df.empty:
            return

        latest_candle = df.iloc[-1]

        # Determine signal
        signal = None
        if latest_candle.get('long_signal', False):
            signal = 'LONG'
        elif latest_candle.get('short_signal', False):
            signal = 'SHORT'

        if signal is None:
            logging.info("No signal generated")
            return

        logging.info(f"ðŸŽ¯ {signal} signal generated @ {latest_candle['close']:.2f}")

        # Calculate SL/TP (customize this based on your strategy)
        entry_price = latest_candle['close']

        if signal == 'LONG':
            stop_loss = entry_price * 0.98  # 2% SL
            take_profit = entry_price * 1.05  # 5% TP
        else:  # SHORT
            stop_loss = entry_price * 1.02  # 2% SL
            take_profit = entry_price * 0.95  # 5% TP

        # Place orders for ALL subscribers
        for subscriber in self.subscribers:
            self.place_order_for_subscriber(subscriber, signal, entry_price, stop_loss, take_profit)

    def backtest(self, historical_data: pd.DataFrame, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Backtest strategy on historical data.

        Required for xcoin CLI compatibility.

        Args:
            historical_data: DataFrame with OHLCV data
            config: Backtest configuration

        Returns:
            Backtest result in xcoin-compatible format:
            {
                'trades': [...],
                'metrics': {...},
                'equity_curve': [...]
            }
        """
        # TODO: Implement backtesting logic
        # This should simulate your strategy on historical data and return results

        logging.info("Running backtest...")

        # Generate signals
        df_with_signals = self.generate_signals(historical_data.copy())

        # Simulate trades (simplified example)
        trades = []
        equity_curve = []
        capital = config.get('initial_capital', 100000)

        # ... (implement your backtesting logic here)

        return {
            'trades': trades,
            'metrics': {
                'total_trades': len(trades),
                'winning_trades': 0,
                'losing_trades': 0,
                'win_rate': 0,
                'total_pnl': 0,
                'total_pnl_pct': 0,
                'max_drawdown': 0,
                'max_drawdown_pct': 0,
                'sharpe_ratio': 0,
                'profit_factor': 0
            },
            'equity_curve': equity_curve
        }

    def run(self):
        """
        Main execution loop (for standalone mode).

        Continuously fetches data, checks for signals, and places orders.
        """
        logging.info(f"Starting LiveTrader for {self.settings['pair']} on {self.settings['resolution']}m timeframe")

        while True:
            try:
                logging.info("\n" + "="*80)
                logging.info(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Running cycle...")

                # Fetch latest data
                df = self.get_latest_data()
                if df.empty or len(df) < 50:
                    logging.warning(f"Insufficient data ({len(df)} candles), skipping cycle")
                    time.sleep(30)
                    continue

                # Generate signals
                df_with_signals = self.generate_signals(df)

                # Check for new signals
                self.check_for_new_signal(df_with_signals)

                # Sleep until next candle
                now = datetime.now()
                res_min = int(self.settings['resolution'])
                seconds_to_wait = (res_min * 60) - (now.minute % res_min * 60 + now.second) + 2
                logging.info(f"Cycle complete. Waiting {seconds_to_wait}s until next candle...")
                time.sleep(seconds_to_wait)

            except Exception as e:
                logging.critical(f"Unexpected error in main loop: {e}", exc_info=True)
                logging.info("Restarting loop in 60 seconds...")
                time.sleep(60)
            except KeyboardInterrupt:
                logging.info("Received KeyboardInterrupt. Exiting...")
                break


# ==============================================================================
# SECTION 4: ENTRY POINT
# ==============================================================================

if __name__ == '__main__':
    setup_logging()

    # Check if running in platform mode (receives input via stdin)
    if not sys.stdin.isatty():
        # Platform mode: Read input from stdin
        try:
            input_data = json.loads(sys.stdin.read())

            bot = LiveTrader(
                settings=input_data['settings'],
                subscribers=input_data.get('subscribers')
            )

            # Run once (scheduled execution)
            df = bot.get_latest_data()
            bot.check_for_new_signal(df)

            # Return success to platform
            print(json.dumps({'success': True, 'message': 'Execution complete'}))
        except Exception as e:
            logging.error(f"Platform execution failed: {e}", exc_info=True)
            print(json.dumps({'success': False, 'error': str(e)}))
            sys.exit(1)
    else:
        # Standalone mode: Load settings from file or environment
        SETTINGS = {
            "api_key": os.getenv("COINDCX_API_KEY"),
            "api_secret": os.getenv("COINDCX_API_SECRET"),

            # Trading Configuration
            "pair": "{{default_pair}}",
            "margin_currency": "USDT",
            "resolution": "{{default_resolution}}",
            "leverage": 10,
            "risk_per_trade": 0.05,  # 5% risk per trade
            "capital": 10000,  # Starting capital in USDT
        }

        # Load from settings file if exists
        settings_file = "strategy_settings.json"
        if os.path.exists(settings_file):
            try:
                with open(settings_file, 'r') as f:
                    user_settings = json.load(f)
                    SETTINGS.update(user_settings)
                    logging.info(f"Loaded settings from {settings_file}")
            except Exception as e:
                logging.warning(f"Could not load {settings_file}: {e}")

        # Validate API keys
        if not SETTINGS.get('api_key') or not SETTINGS.get('api_secret'):
            logging.error("API keys not found. Set COINDCX_API_KEY and COINDCX_API_SECRET environment variables")
            logging.error("Or create strategy_settings.json with your credentials")
            sys.exit(1)

        # Run bot
        bot = LiveTrader(settings=SETTINGS)
        bot.run()

